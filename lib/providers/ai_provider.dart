import 'package:flutter/foundation.dart';
import '../services/openai_service.dart';
import '../services/voice_service.dart';
import '../providers/settings_provider.dart';
import '../providers/pet_provider.dart';
import '../features/pet/models/pet.dart';
import '../features/pet/models/ai_chat_message.dart';
import '../services/realtime_service.dart';

class AIProvider with ChangeNotifier {
  // --- YENƒ∞: √áoklu mesajlƒ± AI sohbeti i√ßin ---
  String? _activeChatId;
  List<AIChatMessage> _activeMessages = [];
  bool _isLoading = false;
  bool _isListening = false;
  bool _isSpeaking = false;
  bool _isContinuousListening = false; // Yeni: s√ºrekli dinleme durumu
  String? _recognizedText;
  String _currentTranscription = ''; // Yeni: anlƒ±k transkripsiyon
  String _statusMessage = ''; // Yeni: durum mesajƒ±
  SettingsProvider? _settingsProvider;
  PetProvider? _petProvider;
  final VoiceService _voiceService = VoiceService();
  final RealtimeService _realtimeService = RealtimeService();

  String? get activeChatId => _activeChatId;
  List<AIChatMessage> get activeMessages => _activeMessages;
  bool get isLoading => _isLoading;
  bool get isListening => _isListening;
  bool get isSpeaking => _isSpeaking;
  bool get isContinuousListening => _isContinuousListening; // Yeni
  String? get recognizedText => _recognizedText;
  String get currentTranscription => _currentTranscription; // Yeni
  String get statusMessage => _statusMessage; // Yeni

  void setSettingsProvider(SettingsProvider settingsProvider) {
    _settingsProvider = settingsProvider;
  }

  void setPetProvider(PetProvider petProvider) {
    _petProvider = petProvider;
  }

  // Yeni bir AI sohbeti ba≈ülat
  Future<void> startNewChat(String petId) async {
    _isLoading = true;
    notifyListeners();
    _activeChatId = await _realtimeService.startNewAIChat(petId);
    _activeMessages = [];
    _isLoading = false;
    notifyListeners();
  }

  // Var olan bir sohbeti y√ºkle (ge√ßmi≈üi g√∂ster)
  void listenToChat(String petId, String chatId) {
    _activeChatId = chatId;
    _realtimeService.getAIChatMessagesStream(petId, chatId).listen((messages) {
      _activeMessages = messages;
      notifyListeners();
    });
  }

  // Kullanƒ±cƒ± mesajƒ± g√∂nder ve AI'dan yanƒ±t al
  Future<void> sendMessageAndGetAIResponse({
    required String petId,
    required Pet pet,
    required String message,
  }) async {
    if (_activeChatId == null) {
      await startNewChat(petId);
    }
    final chatId = _activeChatId!;
    final userMsg = AIChatMessage.text(
      sender: 'user', 
      text: message, 
      timestamp: DateTime.now().millisecondsSinceEpoch
    );
    await _realtimeService.addAIChatMessage(petId, chatId, userMsg);
    _isLoading = true;
    notifyListeners();
    try {
      // Sohbet ge√ßmi≈üini OpenAI'ya g√∂nder
      final conversationStyle = _settingsProvider?.conversationStyle ?? ConversationStyle.friendly;
      final history = List<AIChatMessage>.from(_activeMessages)..add(userMsg);
      final responseText = await OpenAIService.getMultiTurnSuggestion(
        pet: pet,
        history: history,
        style: conversationStyle,
      );
      final aiMsg = AIChatMessage.text(
        sender: 'ai', 
        text: responseText, 
        timestamp: DateTime.now().millisecondsSinceEpoch
      );
      await _realtimeService.addAIChatMessage(petId, chatId, aiMsg);
      // Sesli yanƒ±t
      if (_settingsProvider?.voiceResponseEnabled ?? false) {
        await _voiceService.speak(
          responseText,
          voice: _settingsProvider?.ttsVoice,
          rate: _settingsProvider?.ttsRate,
          pitch: _settingsProvider?.ttsPitch,
        );
      }
    } catch (e) {
      final aiMsg = AIChatMessage.text(
        sender: 'ai', 
        text: 'Hata: $e', 
        timestamp: DateTime.now().millisecondsSinceEpoch
      );
      await _realtimeService.addAIChatMessage(petId, chatId, aiMsg);
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Ses mesajƒ± g√∂nder
  Future<void> sendVoiceMessage({
    required String petId,
    required Pet pet,
    required String voicePath,
    required int duration,
  }) async {
    if (_activeChatId == null) {
      await startNewChat(petId);
    }
    final chatId = _activeChatId!;
    final userMsg = AIChatMessage.voice(
      sender: 'user',
      text: 'Ses mesajƒ±',
      timestamp: DateTime.now().millisecondsSinceEpoch,
      mediaUrl: voicePath,
      voiceDuration: duration,
    );
    await _realtimeService.addAIChatMessage(petId, chatId, userMsg);
    _isLoading = true;
    notifyListeners();
    try {
      // Ses mesajƒ± i√ßin AI yanƒ±tƒ±
      final conversationStyle = _settingsProvider?.conversationStyle ?? ConversationStyle.friendly;
      final history = List<AIChatMessage>.from(_activeMessages)..add(userMsg);
      final responseText = await OpenAIService.getMultiTurnSuggestion(
        pet: pet,
        history: history,
        style: conversationStyle,
      );
      final aiMsg = AIChatMessage.text(
        sender: 'ai',
        text: responseText,
        timestamp: DateTime.now().millisecondsSinceEpoch,
      );
      await _realtimeService.addAIChatMessage(petId, chatId, aiMsg);
      // Sesli yanƒ±t
      if (_settingsProvider?.voiceResponseEnabled ?? false) {
        await _voiceService.speak(
          responseText,
          voice: _settingsProvider?.ttsVoice,
          rate: _settingsProvider?.ttsRate,
          pitch: _settingsProvider?.ttsPitch,
        );
      }
    } catch (e) {
      final aiMsg = AIChatMessage.text(
        sender: 'ai',
        text: 'Hata: $e',
        timestamp: DateTime.now().millisecondsSinceEpoch,
      );
      await _realtimeService.addAIChatMessage(petId, chatId, aiMsg);
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Resim mesajƒ± g√∂nder
  Future<void> sendImageMessage({
    required String petId,
    required Pet pet,
    required String imagePath,
  }) async {
    if (_activeChatId == null) {
      await startNewChat(petId);
    }
    final chatId = _activeChatId!;
    
    // Resim mesajƒ± olu≈ütur
    final userMsg = AIChatMessage.image(
      sender: 'user',
      text: 'üì∑ Resim g√∂nderildi',
      timestamp: DateTime.now().millisecondsSinceEpoch,
      mediaUrl: imagePath,
    );
    
    await _realtimeService.addAIChatMessage(petId, chatId, userMsg);
    _isLoading = true;
    notifyListeners();
    
    try {
      // AI'dan resim hakkƒ±nda yorum al
      final conversationStyle = _settingsProvider?.conversationStyle ?? ConversationStyle.friendly;
      final history = List<AIChatMessage>.from(_activeMessages)..add(userMsg);
      final responseText = await OpenAIService.getMultiTurnSuggestion(
        pet: pet,
        history: history,
        style: conversationStyle,
      );
      
      final aiMsg = AIChatMessage.text(
        sender: 'ai',
        text: responseText,
        timestamp: DateTime.now().millisecondsSinceEpoch,
      );
      await _realtimeService.addAIChatMessage(petId, chatId, aiMsg);
      
      // Sesli yanƒ±t
      if (_settingsProvider?.voiceResponseEnabled ?? false) {
        await _voiceService.speak(
          responseText,
          voice: _settingsProvider?.ttsVoice,
          rate: _settingsProvider?.ttsRate,
          pitch: _settingsProvider?.ttsPitch,
        );
      }
    } catch (e) {
      final aiMsg = AIChatMessage.text(
        sender: 'ai',
        text: 'Hata: $e',
        timestamp: DateTime.now().millisecondsSinceEpoch,
      );
      await _realtimeService.addAIChatMessage(petId, chatId, aiMsg);
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }



  // Sohbet ge√ßmi≈üi listesi (her pet i√ßin)
  Future<List<Map<String, dynamic>>> getChatHistoryList(String petId) async {
    return await _realtimeService.getAIChatList(petId);
  }

  // initializeVoiceService fonksiyonunda TTS ve Whisper callbacklerini ayarla
  Future<void> initializeVoiceService() async {
    await _voiceService.initialize();
    
    // TTS callbacks
    _voiceService.onSpeakingStarted = () {
      _isSpeaking = true;
      notifyListeners();
    };
    _voiceService.onSpeakingStopped = () {
      _isSpeaking = false;
      notifyListeners();
    };
    
    // Whisper callbacks
    _voiceService.onSpeechResult = (text) {
      _recognizedText = text;
      notifyListeners();
      print('üé§ Tanƒ±nan metin: $text');
    };
    _voiceService.onListeningStarted = () {
      _isListening = true;
      notifyListeners();
    };
    _voiceService.onListeningStopped = () {
      _isListening = false;
      notifyListeners();
    };
    _voiceService.onSpeechError = (error) {
      print('‚ùå Sesli konu≈üma hatasƒ±: $error');
      _isListening = false;
      notifyListeners();
    };
    
    // Yeni: S√ºrekli dinleme callbacks
    _voiceService.onContinuousListeningStarted = () {
      _isContinuousListening = true;
      _currentTranscription = '';
      notifyListeners();
      print('üé§ S√ºrekli dinleme ba≈üladƒ±');
    };
    _voiceService.onContinuousListeningStopped = () {
      _isContinuousListening = false;
      notifyListeners();
      print('üé§ S√ºrekli dinleme durdu');
    };
    _voiceService.onContinuousTranscription = (text) {
      _currentTranscription = text;
      notifyListeners();
      print('üé§ Anlƒ±k transkripsiyon g√ºncellendi: $text');
    };
  }

  // startVoiceInput ve stopVoiceInput fonksiyonlarƒ±nƒ± kaldƒ±r

  Future<void> speakResponse(String? text) async {
    if (text != null && text.isNotEmpty) {
      try {
        await _voiceService.speak(
          text,
          voice: _settingsProvider?.ttsVoice,
          rate: _settingsProvider?.ttsRate,
          pitch: _settingsProvider?.ttsPitch,
        );
      } catch (e) {
        print('‚ùå AIProvider speakResponse hatasƒ±: $e');
      }
    }
  }

  Future<void> stopSpeaking() async {
    await _voiceService.stopSpeaking();
  }

  // Whisper ile ses dinleme fonksiyonlarƒ±
  Future<void> startVoiceInput({int seconds = 5}) async {
    // Eƒüer ba≈üka bir ses servisi √ßalƒ±≈üƒ±yorsa, ba≈ülatma
    if (isLoading) {
      print('‚ö†Ô∏è AI i≈ülemi devam ediyor, ses dinleme ba≈ülatƒ±lamƒ±yor');
      return;
    }
    
    await _voiceService.startVoiceInput(seconds: seconds);
  }

  Future<void> stopVoiceInput() async {
    await _voiceService.stopVoiceInput();
  }

  // Yeni: S√ºrekli ses dinleme fonksiyonlarƒ±
  Future<void> startContinuousListening() async {
    _statusMessage = '';
    _isContinuousListening = true;
    notifyListeners();
    await _voiceService.startContinuousListening();
  }

  Future<void> stopContinuousListening({Pet? currentPet}) async {
    print('üõë AI Provider: S√ºrekli dinleme durduruluyor...');
    _isContinuousListening = false;
    notifyListeners();
    
    final result = await _voiceService.stopContinuousListening();
    if (result != null && result.isNotEmpty) {
      _recognizedText = result;
      _statusMessage = 'Ses tanƒ±ma tamamlandƒ±, i≈üleniyor...';
      notifyListeners();
      
      // Otomatik olarak AI yanƒ±tƒ± al (sadece pet varsa)
      if (_activeChatId != null && currentPet != null) {
        try {
          await sendMessageAndGetAIResponse(
            petId: currentPet.id ?? currentPet.name,
            pet: currentPet,
            message: result,
          );
          _statusMessage = '';
        } catch (e) {
          if (e.toString().contains('rate limit') || e.toString().contains('429')) {
            _statusMessage = 'API limit a≈üƒ±ldƒ±, l√ºtfen birka√ß dakika bekleyin...';
          } else {
            _statusMessage = 'Bir hata olu≈ütu: ${e.toString()}';
          }
        }
        notifyListeners();
      } else {
        // Pet yoksa sadece tanƒ±nan metni g√∂ster
        _statusMessage = 'Ses tanƒ±ma tamamlandƒ±';
        notifyListeners();
      }
    } else {
      _statusMessage = '';
      notifyListeners();
    }
    print('‚úÖ AI Provider: S√ºrekli dinleme durduruldu');
  }

  void clearStatusMessage() {
    _statusMessage = '';
    notifyListeners();
  }

  void clearCurrentTranscription() {
    _voiceService.clearCurrentTranscription();
  }

  void clearActiveChat() {
    _activeChatId = null;
    _activeMessages = [];
    notifyListeners();
  }

  void clearRecognizedText() {
    _recognizedText = null;
    notifyListeners();
  }

  // Sesli komutlarƒ± i≈üle ve uygun aksiyonlarƒ± ger√ßekle≈ütir
  Future<void> processVoiceCommand(String command, Pet currentPet) async {
    print('üé§ Sesli komut i≈üleniyor: $command');
    
    final lowerCommand = command.toLowerCase();
    
    // Besleme komutlarƒ±
    if (lowerCommand.contains('besle') || lowerCommand.contains('yemek') || lowerCommand.contains('mama')) {
      await _feedPet(currentPet);
      return;
    }
    
    // Oyun komutlarƒ±
    if (lowerCommand.contains('oyna') || lowerCommand.contains('oyun') || lowerCommand.contains('eƒülendir')) {
      await _playWithPet(currentPet);
      return;
    }
    
    // Bakƒ±m komutlarƒ±
    if (lowerCommand.contains('bakƒ±m') || lowerCommand.contains('temizle') || lowerCommand.contains('tara')) {
      await _groomPet(currentPet);
      return;
    }
    
    // A≈üƒ± komutlarƒ±
    if (lowerCommand.contains('a≈üƒ±') || lowerCommand.contains('vaccine')) {
      await _processVaccineCommand(command, currentPet);
      return;
    }
    
    // Enerji komutlarƒ±
    if (lowerCommand.contains('enerji') || lowerCommand.contains('dinlendir') || lowerCommand.contains('uyku')) {
      await _restPet(currentPet);
      return;
    }
    
    // Genel durum sorgulama
    if (lowerCommand.contains('durum') || lowerCommand.contains('nasƒ±l') || lowerCommand.contains('deƒüer')) {
      await _checkPetStatus(currentPet);
      return;
    }
    
    // Eƒüer hi√ßbir komut e≈üle≈ümezse, normal AI yanƒ±tƒ± al
    await sendMessageAndGetAIResponse(
      petId: currentPet.id ?? currentPet.name,
      pet: currentPet,
      message: command,
    );
  }

  // Tanƒ±nan metni sesli komut olarak i≈üle (sadece komut modunda)
  Future<void> processRecognizedTextAsCommand(Pet currentPet) async {
    if (_recognizedText != null && _recognizedText!.isNotEmpty) {
      await processVoiceCommand(_recognizedText!, currentPet);
      clearRecognizedText(); // ƒ∞≈ülem tamamlandƒ±ktan sonra temizle
    }
  }

  // Pet besleme fonksiyonu
  Future<void> _feedPet(Pet pet) async {
    if (_petProvider == null) return;
    
    try {
      // Tokluk deƒüerini artƒ±r
      pet.satiety = (pet.satiety + 3).clamp(0, 10);
      pet.lastUpdate = DateTime.now();
      
      // Pet'i g√ºncelle
      await _petProvider!.updatePet(pet.name, pet);
      
      // Ba≈üarƒ± mesajƒ± g√∂nder
      final response = '${pet.name} ba≈üarƒ±yla beslendi! üçñ Tokluk seviyesi: ${pet.satiety}/10';
      await _sendAIResponse(pet, response);
      
      print('‚úÖ ${pet.name} beslendi');
    } catch (e) {
      print('‚ùå Besleme hatasƒ±: $e');
      await _sendAIResponse(pet, 'Besleme sƒ±rasƒ±nda bir hata olu≈ütu: $e');
    }
  }

  // Pet ile oyun oynama fonksiyonu
  Future<void> _playWithPet(Pet pet) async {
    if (_petProvider == null) return;
    
    try {
      // Mutluluk ve enerji deƒüerlerini artƒ±r
      pet.happiness = (pet.happiness + 2).clamp(0, 10);
      pet.energy = (pet.energy - 1).clamp(0, 10); // Oyun enerji t√ºketir
      pet.lastUpdate = DateTime.now();
      
      // Pet'i g√ºncelle
      await _petProvider!.updatePet(pet.name, pet);
      
      // Ba≈üarƒ± mesajƒ± g√∂nder
      final response = '${pet.name} ile harika bir oyun oynadƒ±nƒ±z! üéæ Mutluluk: ${pet.happiness}/10, Enerji: ${pet.energy}/10';
      await _sendAIResponse(pet, response);
      
      print('‚úÖ ${pet.name} ile oyun oynandƒ±');
    } catch (e) {
      print('‚ùå Oyun hatasƒ±: $e');
      await _sendAIResponse(pet, 'Oyun sƒ±rasƒ±nda bir hata olu≈ütu: $e');
    }
  }

  // Pet bakƒ±m fonksiyonu
  Future<void> _groomPet(Pet pet) async {
    if (_petProvider == null) return;
    
    try {
      // Bakƒ±m deƒüerini artƒ±r
      pet.care = (pet.care + 3).clamp(0, 10);
      pet.lastUpdate = DateTime.now();
      
      // Pet'i g√ºncelle
      await _petProvider!.updatePet(pet.name, pet);
      
      // Ba≈üarƒ± mesajƒ± g√∂nder
      final response = '${pet.name} i√ßin bakƒ±m yapƒ±ldƒ±! üõÅ Bakƒ±m seviyesi: ${pet.care}/10';
      await _sendAIResponse(pet, response);
      
      print('‚úÖ ${pet.name} bakƒ±mƒ± yapƒ±ldƒ±');
    } catch (e) {
      print('‚ùå Bakƒ±m hatasƒ±: $e');
      await _sendAIResponse(pet, 'Bakƒ±m sƒ±rasƒ±nda bir hata olu≈ütu: $e');
    }
  }

  // Pet dinlendirme fonksiyonu
  Future<void> _restPet(Pet pet) async {
    if (_petProvider == null) return;
    
    try {
      // Enerji deƒüerini artƒ±r
      pet.energy = (pet.energy + 3).clamp(0, 10);
      pet.lastUpdate = DateTime.now();
      
      // Pet'i g√ºncelle
      await _petProvider!.updatePet(pet.name, pet);
      
      // Ba≈üarƒ± mesajƒ± g√∂nder
      final response = '${pet.name} dinlendi ve enerji topladƒ±! üò¥ Enerji seviyesi: ${pet.energy}/10';
      await _sendAIResponse(pet, response);
      
      print('‚úÖ ${pet.name} dinlendirildi');
    } catch (e) {
      print('‚ùå Dinlendirme hatasƒ±: $e');
      await _sendAIResponse(pet, 'Dinlendirme sƒ±rasƒ±nda bir hata olu≈ütu: $e');
    }
  }

  // A≈üƒ± komutlarƒ±nƒ± i≈üleme
  Future<void> _processVaccineCommand(String command, Pet pet) async {
    if (_petProvider == null) return;
    
    final lowerCommand = command.toLowerCase();
    
    // A≈üƒ± ekleme komutlarƒ±
    if (lowerCommand.contains('ekle') || lowerCommand.contains('yaptƒ±r') || lowerCommand.contains('yaptƒ±rdƒ±m')) {
      await _addVaccine(command, pet);
      return;
    }
    
    // A≈üƒ± listesi g√∂r√ºnt√ºleme
    if (lowerCommand.contains('liste') || lowerCommand.contains('g√∂ster') || lowerCommand.contains('ne zaman')) {
      await _showVaccineList(pet);
      return;
    }
    
    // A≈üƒ± tamamlama
    if (lowerCommand.contains('tamamla') || lowerCommand.contains('yapƒ±ldƒ±')) {
      await _completeVaccine(command, pet);
      return;
    }
  }

  // A≈üƒ± ekleme
  Future<void> _addVaccine(String command, Pet pet) async {
    try {
      // Komuttan a≈üƒ± adƒ±nƒ± ve tarihini √ßƒ±kar
      String vaccineName = '';
      DateTime vaccineDate = DateTime.now();
      
      // Basit a≈üƒ± adƒ± √ßƒ±karma
      if (command.contains('kuduz')) {
        vaccineName = 'Kuduz A≈üƒ±sƒ±';
      } else if (command.contains('karma')) {
        vaccineName = 'Karma A≈üƒ±';
      } else if (command.contains('parazit')) {
        vaccineName = 'Parazit A≈üƒ±sƒ±';
      } else if (command.contains('corona')) {
        vaccineName = 'Corona A≈üƒ±sƒ±';
      } else {
        vaccineName = 'A≈üƒ±';
      }
      
      // Tarih √ßƒ±karma
      if (command.contains('bug√ºn')) {
        vaccineDate = DateTime.now();
      } else if (command.contains('yarƒ±n')) {
        vaccineDate = DateTime.now().add(Duration(days: 1));
      } else if (command.contains('haftaya')) {
        vaccineDate = DateTime.now().add(Duration(days: 7));
      } else if (command.contains('ay sonra')) {
        vaccineDate = DateTime.now().add(Duration(days: 30));
      }
      
      // G√ºn sayƒ±sƒ± √ßƒ±karma (√∂rn: "5 g√ºn sonra")
      final dayMatch = RegExp(r'(\d+)\s*g√ºn\s*sonra').firstMatch(command);
      if (dayMatch != null) {
        final days = int.parse(dayMatch.group(1)!);
        vaccineDate = DateTime.now().add(Duration(days: days));
      }
      
      // A≈üƒ±yƒ± ekle
      final vaccine = Vaccine(
        name: vaccineName,
        date: vaccineDate,
        isDone: command.contains('yaptƒ±rdƒ±m') || command.contains('yapƒ±ldƒ±'),
      );
      
      pet.vaccines.add(vaccine);
      await _petProvider!.updatePet(pet.name, pet);
      
      final status = vaccine.isDone ? 'yapƒ±ldƒ±' : 'planlandƒ±';
      final response = '${pet.name} i√ßin $vaccineName $status! üìÖ Tarih: ${vaccineDate.day}/${vaccineDate.month}/${vaccineDate.year}';
      await _sendAIResponse(pet, response);
      
      print('‚úÖ A≈üƒ± eklendi: $vaccineName');
    } catch (e) {
      print('‚ùå A≈üƒ± ekleme hatasƒ±: $e');
      await _sendAIResponse(pet, 'A≈üƒ± ekleme sƒ±rasƒ±nda bir hata olu≈ütu: $e');
    }
  }

  // A≈üƒ± listesi g√∂sterme
  Future<void> _showVaccineList(Pet pet) async {
    try {
      if (pet.vaccines.isEmpty) {
        await _sendAIResponse(pet, '${pet.name} i√ßin hen√ºz a≈üƒ± kaydƒ± bulunmuyor.');
        return;
      }
      
      String response = '${pet.name} i√ßin a≈üƒ± listesi:\n';
      for (final vaccine in pet.vaccines) {
        final status = vaccine.isDone ? '‚úÖ' : 'üìÖ';
        final date = '${vaccine.date.day}/${vaccine.date.month}/${vaccine.date.year}';
        response += '$status ${vaccine.name} - $date\n';
      }
      
      await _sendAIResponse(pet, response);
    } catch (e) {
      print('‚ùå A≈üƒ± listesi hatasƒ±: $e');
      await _sendAIResponse(pet, 'A≈üƒ± listesi g√∂r√ºnt√ºlenirken hata olu≈ütu: $e');
    }
  }

  // A≈üƒ± tamamlama
  Future<void> _completeVaccine(String command, Pet pet) async {
    try {
      // Komuttan a≈üƒ± adƒ±nƒ± √ßƒ±kar
      String vaccineName = '';
      if (command.contains('kuduz')) {
        vaccineName = 'Kuduz A≈üƒ±sƒ±';
      } else if (command.contains('karma')) {
        vaccineName = 'Karma A≈üƒ±';
      } else if (command.contains('parazit')) {
        vaccineName = 'Parazit A≈üƒ±sƒ±';
      } else if (command.contains('corona')) {
        vaccineName = 'Corona A≈üƒ±sƒ±';
      }
      
      // A≈üƒ±yƒ± bul ve tamamla
      final vaccine = pet.vaccines.firstWhere(
        (v) => v.name.toLowerCase().contains(vaccineName.toLowerCase()),
        orElse: () => Vaccine(name: '', date: DateTime.now()),
      );
      
      if (vaccine.name.isNotEmpty) {
        vaccine.isDone = true;
        vaccine.date = DateTime.now();
        await _petProvider!.updatePet(pet.name, pet);
        
        await _sendAIResponse(pet, '${pet.name} i√ßin $vaccineName tamamlandƒ±! ‚úÖ');
        print('‚úÖ A≈üƒ± tamamlandƒ±: $vaccineName');
      } else {
        await _sendAIResponse(pet, 'Belirtilen a≈üƒ± bulunamadƒ±.');
      }
    } catch (e) {
      print('‚ùå A≈üƒ± tamamlama hatasƒ±: $e');
      await _sendAIResponse(pet, 'A≈üƒ± tamamlama sƒ±rasƒ±nda hata olu≈ütu: $e');
    }
  }

  // Pet durumu kontrol etme
  Future<void> _checkPetStatus(Pet pet) async {
    try {
      final response = '''${pet.name} durumu:
üçñ Tokluk: ${pet.satiety}/10
üòä Mutluluk: ${pet.happiness}/10
‚ö° Enerji: ${pet.energy}/10
üõÅ Bakƒ±m: ${pet.care}/10

${pet.age} ya≈üƒ±nda ${pet.gender} ${pet.type}''';
      
      await _sendAIResponse(pet, response);
    } catch (e) {
      print('‚ùå Durum kontrol√º hatasƒ±: $e');
      await _sendAIResponse(pet, 'Durum kontrol√º sƒ±rasƒ±nda hata olu≈ütu: $e');
    }
  }

  // AI yanƒ±tƒ± g√∂nderme yardƒ±mcƒ± fonksiyonu
  Future<void> _sendAIResponse(Pet pet, String response) async {
    if (_activeChatId == null) {
      await startNewChat(pet.id ?? pet.name);
    }
    
    final chatId = _activeChatId!;
    final aiMsg = AIChatMessage(
      sender: 'ai', 
      text: response, 
      timestamp: DateTime.now().millisecondsSinceEpoch
    );
    
    await _realtimeService.addAIChatMessage(pet.id ?? pet.name, chatId, aiMsg);
    
    // Sesli yanƒ±t
    if (_settingsProvider?.voiceResponseEnabled ?? false) {
      await _voiceService.speak(
        response,
        voice: _settingsProvider?.ttsVoice,
        rate: _settingsProvider?.ttsRate,
        pitch: _settingsProvider?.ttsPitch,
      );
    }
  }

  @override
  void dispose() {
    _voiceService.dispose();
    super.dispose();
  }
} 